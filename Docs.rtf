{\rtf1\ansi\ansicpg1252\deff0\deftab709{\fonttbl{\f0\froman\fprq2\fcharset0 Times New Roman;}}
{\colortbl ;\red0\green0\blue255;\red128\green0\blue0;}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\qc\lang1033\b\f0\fs30 Xero Sum Technical Documentation\par
\fs28\par
\pard Brief Tutorial\b0\fs24\par
\tab At this point, Xero Sum is divided into two main parts. There is {\field{\*\fldinst{HYPERLINK "\\\\l "main_py" "}}{\fldrslt{\cf2\lang255\ul main.py}}}\cf0\lang1033\ulnone\f0\fs24  that executes the main program loop and the data object types that store the data and reflect changes in the state of the game world. One could also make and display a world using their own version of main.py. In this tutorial we will create a Xero Sum World object and use a WorldView object to draw it to the screen.\par
 \par
-First create a new python file in the same directory as the Xero Sum. I am going to call my file \ldblquote demo.py\rdblquote  and will leave it in the main directory of Xero Sum.\par
-The first few lines we will need to import the modules and classes we need.\par
\par
\i import pygame, sys\par
from AoE import *\i0\par
\i from World import World\i0\par
\i from WorldView import WorldView\i0\par
\par
\tab Pygame is the renderer used to draw to the screen. We will also import sys, which is standard python module. We will use sys to exit the program more gracefully. After the first line we have some Xero Sum specific modules: AoE, World and WorldView. World is the object that stores all the other game obejcts. It controls the database to store and retrieve these objects. WorldView is an object that takes an area of the World object and gathers all the data needed to display that area of the World. AoE (short for Area of Effect) is a module that defines Shape objects. Shape objects are a convenient way to store lists of coordinates. WorldView objects use Shapes to define the set of Coordinates of the view.\par
\par
Next, we will have some lines of code for initialization of the Pygame display surface. Before anything can be drawn we have to initialize pygame and tell it the size of the display we want.\par
\par
\i pygame.init()\par
SCREEN_SIZE = [pygame.display.Info().current_w, pygame.display.Info().current_h]\i0\par
\i SCREEN = pygame.display.set_mode(SCREEN_SIZE, pygame.FULLSCREEN)\i0\par
\b\par
\b0 Now, we come to some more Xero Sum specific lines of code.\par
\par
\i WORLD = World("DEMO")\par
originKey = '0_0_0'\i0\par
\i cubeargs = \{'origin': originKey, 'magnitude': [10,10,0], 'towardsNegInf': False\}\i0\par
\i shape = Cube(**cubeargs)\i0\par
\i VIEW = WorldView(WORLD, shape, SCREEN_SIZE)\i0\par
\par
\tab We make a World Object and name it \ldblquote DEMO\rdblquote . This does more than is readily apparent. It also creates a python shelve object to use as a database. The name of the shelve object will be "World Name" + "Shelf". Or "DEMOShelf" in this example. We will also need a coordinate to be the center or focus of the WorldView object we will be making. I choose X=0, Y=0, Z=0 and store these three values in a string named originKey. Each of the axes' value is seperated by an underscore. \par
\tab Next, I create a dictionary of arguments to be used in creating a Shape object. Most objects in Xero Sum are created in this manner. A dictionary of values are made and then an object is created using them. This approach facilitates useful inheritance as the same dictionary can be passed from each object class to it's parent class and each class can be made to use the arguments stored in keys that pertain to it and ignore the rest. The length of the dictionary can also be kept short if each class is given default values to use in the case that the dictionary doesn't override those defaults.\par
\tab The Shape being created has an origin at "0_0_0", a magnitude (or size) of 10x10x0(really becomes 10x10x1) and the "towardsNegInf" argument places the origin in the center of the shape, rather than at the "bottom left" corner of it. Now, we make the Shape usign the Cube class constructor and the cubeargs dictionary. Then we create our WorldView object and store it in the variable VIEW.\par
\tab When VIEW is initialized, it does some things behind the scenes. It takes the Shape it was given and determines which Chunks of the World are involved and it adds those Chunks to the dictionary of active Chunks stored by the World. It also creates a pygame Surface to render onto and which we will later draw to the display. We could display VIEW at this point, but there would be nothing to see until we fill the World with some terrain and objects.\par
\par
\i #Fill active chunks in VIEW with terrain\par
baseTerrain = \{'imageKey': 'grass.png'\}\par
rocks = \{'imageKey':'rocks.png', 'speedModifier': 1.25, 'layer': 1.0\}\par
bushes = \{'imageKey': 'bush.png', 'speedModifier': 1.50, 'layer': 1.1\}\par
for key in sorted(WORLD.active.keys()):\par
        WORLD.baseTerrainChunkFill(key, **baseTerrain)\par
        WORLD.randomFillChunkFeature(key, **rocks)\par
        WORLD.randomFillChunkFeature(key, **bushes)\par
\i0\tab    \par
\tab To make the World more interesting, we create a few dictionaries of arguments describing various types of terrain. In this case, a grassy base terrain to go down first and then some rocks and bushes for flavor. We then pass each one of these arguments of dictionaries to a method of WORLD so that it can add them to the database as appropriate. We pass the arguments rather than an object so that each rock or bush can be created and stored as a unique object. We use an iteration throught the active Chunks by key to add the desired terrain features to each Chunk.\par
\par
\i #Render the VIEW now that there is somethign to see\par
VIEW.render()\par
SCREEN.blit(VIEW.surface, (0,0))\par
pygame.display.flip() \par
\i0\par
\tab Now that we have a VIEW populated with terrain to draw, we use the render method of VIEW to cause it to draw all the on screen objects to its own pygame Surface and then we blit VIEWs' Surface to the SCREEN. Finally, we have pygame flip the display to refresh the physical screen's display. If we ran the demo.py at this point it would likely draw to the screen and then disappear before we had a chance to see much of anything. We need a simple main control loop to keep the program running until we wish to exit it.\par
\par
\i #Main control loop\par
while True:\par
    for event in pygame.event.get():#Go through all events\par
        if event.type == pygame.QUIT: #If the little x in the window was clicked...\par
            WORLD.close()\par
            sys.exit()\par
        if event.type == pygame.KEYDOWN:\par
            pressed_keys = pygame.key.get_pressed()\par
            if pressed_keys[pygame.K_ESCAPE]:\par
                WORLD.close()\par
                sys.exit()  \par
\i0\par
\tab With this control loop in the code, the World is created and drawn once. Then the progam waits until the Escape key is pressed to exit. Now we can actually see what we have made. Each time we run the demo.py there will be more and more terrain added. If we wish to delete the World and start over again, we must find the "DEMOShelf" file and delete that as it contains the World's database. Then, a new database will be created the next time the demo.py is run.\par
\par
\pard\qc\b\fs28 main.py\par
\pard\b0\fs24\par
\tab main.py is the entry point into the execution of Xero Sum. When run it will change the path variable to the file directory where main.py resides. This is necessary so that it can find expected files relative to that absolute path (Xero Sum imports, game resources, etc).\par
main.py is divided into four major sections that occur roughly in this linear order in the file:\par
\pard\fi-360\li360 1.\tab import statements\par
2.\tab main loop definition\par
3.\tab user inputs definitions\par
4.\tab world initialization\par
\pard\par
Import Statements in main.py\par
\tab\par
\par
}
 